# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

clr <- function(x) {
    .Call('_Scribe_clr', PACKAGE = 'Scribe', x)
}

kde_cpp <- function(data, k = 1L, b = 1L, pdf = 1L, density_sample_type = 1L) {
    .Call('_Scribe_kde_cpp', PACKAGE = 'Scribe', data, k, b, pdf, density_sample_type)
}

#' @title
#' kde
#' @description
#' This subroutine calculates the 2d density for a two dimensional matrix using kernel density estimator. 
#' 
#' @param data A two dimensional matrix, data, where the first row correspondds to the sample and column corresponds to the dimensions.
#' @param k Kernel type. 1 = Gaussian (default); 2 = Box; 3 = Epanechnikov
#' @param b Bandwidth optimisation (Gaussian only). 1 = Default; 2 = AMISE optimal, secant method; 3 = AMISE optimal, bisection method
#' @param pdf Calculate PDF or CDF. 1 = PDF (default); 2 = CDF.
#' @param density_sample_type Where do you want to calculate the kde density. 1 = Original data points (default); 2 = on a pre-defined grid.  
#' 
#' @details
#' \code{kde} takes a 2D matrix and uses kernel density estimator to calculate the density 
#' at location of the original data points (default) or a grid of points. For a one dimension matrix, 
#' the grid is calculated on 1001 evenly spaced points while for a two dimensional matrix, it will be 
#' calculated on 201 evenly spaced points on each dimension (201 x 201 points in total).  
#' @return a NumericMatrix where the element is the density estimate (name: density_estimate), 
#' the second one is the weight calculated based on density_estimate. This function is based on from Tim Nugent
#' (https://github.com/timnugent/kernel-density).  
#' @export
kde <- function(data, k, b, pdf, density_sample_type) {
    .Call('_Scribe_kde', PACKAGE = 'Scribe', data, k, b, pdf, density_sample_type)
}

#'  This subroutine calculates the volume of a d-dimensional unit ball for Euclidean norm
NULL

#' This function estimates the entropy of a continuous random variable
NULL

#' This function estimates the CONDITIONAL mutual information of X and Y given Z
#' Multiply a number by two
#'
NULL

#' @title
#' knn_density
#' @description
#' This subroutine calculates the 1d density of x at positions y 
#' 
#' @param x 1d vector of the data 
#' @param y 1d vector of querying points, positions used to estimate the density 
#' @param k number of nearest neighbors used to estimate the 1d density, default to be 5 
#' 
#' @details
#' \code{knn_density} takes a vector of original data points x and a vector of querying points y
#' to calculate the density at each point y using the k-nearest neighbors. 
#' @return a List where the element is the density estimate (name: density_estimate), 
#' the second one is the weight calculated based on density_estimate.  
#' @export
knn_density <- function(x, y, k) {
    .Call('_Scribe_knn_density', PACKAGE = 'Scribe', x, y, k)
}

#' @title
#' knn_density_2d
#' @description
#' This subroutine calculates the density for a 2d space. 
#' 
#' @param x A vector for the values of the data on the first dimension 
#' @param y A vector for the values of the data on the second dimension 
#' @param nGrids A vector of two for the grid numbers on the first and second dimension 
#' @param k number of nearest neighbors used to calculate the 2d density 
#' 
#' @details
#' \code{knn_density_2d} 
#' @return a numeric value for the d-dimensional unit ball for Euclidean norm
#' @export a matrix of density estimate, calculated on the center of each grid from the data x and y. 
knn_density_2d <- function(x, y, nGrids, k) {
    .Call('_Scribe_knn_density_2d', PACKAGE = 'Scribe', x, y, nGrids, k)
}

digamma_0 <- function(x) {
    .Call('_Scribe_digamma_0', PACKAGE = 'Scribe', x)
}

#' @title
#' vd
#' @description
#' This subroutine calculates the volume of a d-dimensional unit ball for Euclidean norm
#' 
#' @param d number of dimension
#' 
#' @details
#' \code{vd} takes a integer of dimensions and then calculate the volume of a d-dimensional unit ball for Euclidean norm
#' using the formula: 0.5 * d * log(pi) - log(gamma(0.5 * d + 1))
#' It's implimented in C++, providing a (small) increase in speed over the R equivalent.
#' @return a numeric value for the d-dimensional unit ball for Euclidean norm
#' @export
vd <- function(d) {
    .Call('_Scribe_vd', PACKAGE = 'Scribe', d)
}

#' @title
#' entropy
#' @description
#' This subroutine estimates the entropy of a continuous random variable
#' 
#' @param x data matrix used for calculating the entropy
#' 
#' @param k number for nearest neighbors used in entropy calculation
#'
#' @details
#' \code{entropy} takes a continuous random variable and then estimates
#' entropy using the KSG estimator. 
#' It relies on the ANN package to query the kNN with KDTree algorithm.  
#' @return a numeric value of entropy estimate
#' @export
entropy <- function(x, k) {
    .Call('_Scribe_entropy', PACKAGE = 'Scribe', x, k)
}

#' @title
#' mi
#' @description
#' This function estimates the mutual information of two random variables, x, y, based on their observed values
#' 
#' @param x one random variable from the time-series data
#' 
#' @param y another random variable from the time-series data
#'
#' @param k number for nearest neighbors used in entropy calculation
#'
#' @param normalize A logic flag to determine whether or not you want to normalize the MI value by the density of x. 
#'
#' @details
#' \code{mi} takes two random variables x and y to estimate the mutual information between them 
#' using the KSG estimator
#' It relies on the ANN package to query the kNN with KDTree algorithm. 
#' @return a estimated mutual information value between two variables (x, y)
#' @export
mi <- function(x, y, k, normalize) {
    .Call('_Scribe_mi', PACKAGE = 'Scribe', x, y, k, normalize)
}

#' @title
#' cmi
#' @description
#' This subroutine calculates the volume of a d-dimensional unit ball for Euclidean norm
#' 
#' @param x one random variable from the time-series data
#' 
#' @param y another random variable from the time-series data
#'
#' @param z condition random variable for variables (x, y) from the time-series data
#'
#' @param k number for nearest neighbors used in entropy calculation
#'
#' @param normalize A logic flag to determine whether or not you want to normalize the MI value by the density of x. 
#'
#' @details
#' \code{cmi} takes two random variable x and y and estimated their mutual information conditioned on the third random variable z
#' using the KSG estimator. 
#' It relies on the ANN package to query the kNN with KDTree algorithm. 
#' @return a estimated conditional mutual information value between two variables (x, y), conditioning on a third variable z. 
#' @export
cmi <- function(x, y, z, k, normalize) {
    .Call('_Scribe_cmi', PACKAGE = 'Scribe', x, y, z, k, normalize)
}

ucmi_cpp <- function(x, y, z, k, method, k_density, bw) {
    .Call('_Scribe_ucmi_cpp', PACKAGE = 'Scribe', x, y, z, k, method, k_density, bw)
}

#' @title
#' ucmi
#' @description
#' This subroutine calculates the uniformed conditional mutual information where 
#' the distribution for x and z is replaced by a uniform distribution.  
#' 
#' @param x one random variable from the time-series data
#' @param y another random variable from the time-series data
#' @param z condition random variable for variables (x, y) from the time-series data
#' @param k number for nearest neighbors used in entropy calculation
#' @param method Which 2D density estimator you would like to use. 1 is kde estimator and 2 is knn based estimator. 
#' @param k_density The number of k nearest neighbors you would like to use when calculating the density 
#' (only applicable when method == 2 or using knn based density estimation). 
#' @param bw Bindwidth used for the kernel density estimator. Currently it is not used. The bindwidth in the kde function is automatically estimated. 
#' 
#' @details
#' \code{ucmi} takes two random variable x and y and estimated their mutual information conditioned on the third random variable z
#' using the KSG estimator while x, y is replaced by a uniform distribution. It relies on a C++ implmentation of kde estimator 
#' (https://github.com/timnugent/kernel-density) and the ANN package to query the kNN with KDTree algorithm. 
#' @return  a estimated conditional mutual information value between two variables (x, y), conditioning on a third variable z where 
#' the distribution for the x, z is replaced by a uniform distribution. 
#'  
#' @export
ucmi <- function(x, y, z, k, method, k_density, bw) {
    .Call('_Scribe_ucmi', PACKAGE = 'Scribe', x, y, z, k, method, k_density, bw)
}

umi_cpp <- function(x, y, k, method, k_density, bw) {
    .Call('_Scribe_umi_cpp', PACKAGE = 'Scribe', x, y, k, method, k_density, bw)
}

#' @title
#' umi
#' @description
#' This subroutine calculates the uniformed  mutual information where 
#' the distribution for x is replaced by a uniform distribution.  
#' 
#' @param x one random variable from the time-series data
#' @param y another random variable from the time-series data
#' @param k number for nearest neighbors used in entropy calculation
#' @param method Which 2D density estimator you would like to use. 1 is kde estimator and 2 is knn based estimator. 
#' @param k_density The number of k nearest neighbors you would like to use when calculating the density 
#' (only applicable when method == 2 or using knn based density estimation). 
#' @param bw Bindwidth used for the kernel density estimator. Currently it is not used. The bindwidth in the kde function is automatically estimated. 
#' 
#' @details
#' \code{umi} takes two random variable x and y and estimated their mutual using the KSG estimator while x is replaced by a uniform distribution. 
#' It relies on a C++ implmentation of kde estimator (https://github.com/timnugent/kernel-density) and the ANN package to query the kNN with KDTree algorithm. 
#' @return  A estimated uniform mutual information value between two variables (x, y) where the distribution for the x is replaced by a uniform distribution. 
#'  
#' @export
umi <- function(x, y, k, method, k_density, bw) {
    .Call('_Scribe_umi', PACKAGE = 'Scribe', x, y, k, method, k_density, bw)
}

#' @title
#' di_single_run
#' @description
#' This function estimates the DIRECTED mutual information from X to Y when you have a SINGLE run of the process
#' 
#' @param x one random variable from the time-series data
#' 
#' @param y another random variable from the time-series data
#'
#' @param n Parameter n determines the the number of previous time samples upon which the mi is conditioned (delay in the formula I(x-->y)=I(x_{t-d};y_t|y_{t-1}) default: d=1)
#'
#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. 
#' @details
#' \code{di_single_run} takes two random variables x and y as well as a delay n to estimate the direct information between variable x and y. 
#' @return a matrix for the condition mutual information estimators between all pairwise variables (x, y) in the data matrix x, y
#' @export
di_single_run <- function(x, y, n, uniformalize) {
    .Call('_Scribe_di_single_run', PACKAGE = 'Scribe', x, y, n, uniformalize)
}

#' @title
#' di_single_run_conditioned
#' @description
#' This function estimates the CONDITIONED DIRECTED mutual information from X to Y, conditioning on a third variable, z, when you have a SINGLE run of the processes
#' 
#' @param x one random variable from the time-series data
#' 
#' @param y another random variable from the time-series data
#'
#' @param z z is a dataframe (or matrix) containing the data of other processes upon the past of which the mi is conditioned
#' 
#' @param n Parameter n determines the the number of previous time samples upon which the mi is conditioned
#' 
#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. 
#' @details
#' \code{di_single_run_conditioned} takes two random variables x, y and z as well as the parameter n to calculate the direct information conditioned on variable z. 
#' @return a numeric value for the condition mutual information estimator variables (x, y), conditioning on a third variable, z. 
#' @export
di_single_run_conditioned <- function(x, y, z, n, uniformalize) {
    .Call('_Scribe_di_single_run_conditioned', PACKAGE = 'Scribe', x, y, z, n, uniformalize)
}

#' @title
#' rdi_many_runs
#' @description
#' This function estimates the DIRECTED mutual information from X to Y when you have multiple run of the processes.
#' 
#' @param x a random variable with multiple run of the same process.
#' 
#' @param y another random variable with multiple run of another process.
#'
#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. 
#' @details
#' \code{rdi_many_runs} takes two random variables (with the same multiple realization of the two processes) and estimate 
#' the direct information between them at each time point. It then sums up those information estimators. This function can
#' only be used when you have hundreds runs of the same time-series experiment. 
#' @return a numeric value storing the DI from two multiple run variables
#' @export
rdi_many_runs <- function(x, y, uniformalize) {
    .Call('_Scribe_rdi_many_runs', PACKAGE = 'Scribe', x, y, uniformalize)
}

#' @title
#' rdi_single_run
#' @description
#' This function estimates the RESTRICTED DIRECTED mutual information from X to Y when you have a SINGLE run of the processes
#' 
#' @param x one random variable from the time-series data
#' 
#' @param y another random variable from the time-series data
#' 
#' @param d delay in the formula I(x-->y)=I(x_{t-d};y_t|y_{t-1}) default: d=1
#'
#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. 
#' @details
#' \code{rdi_single_run} takes two random variables x and y as well as a time delay d to estimate the restricted direct infomation between them.
#' @return a numeric value for the restricted direct information between x and y with a time delay d = 1. 
#' @export
rdi_single_run <- function(x, y, d, uniformalize) {
    .Call('_Scribe_rdi_single_run', PACKAGE = 'Scribe', x, y, d, uniformalize)
}

#' @title
#' lmi_single_run
#' @description
#' This subroutine calculates the lagged mutual information 
#' 
#' @param x one random variable from the time-series data
#' 
#' @param y another random variable from the time-series data
#'
#' @param delay Time lags used to estimate the RDI values  
#'
#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. 
#' @details
#' \code{lmi_single_run} takes two random variable x and y and estimated their mutual information with a time lag d. 
#' using the KSG estimator. 
#' It relies on the ANN package to query the kNN with KDTree algorithm. 
#' @return a numeric value for the mutual information estimator between two variables (x, y) with a time lag d.
#' @export
lmi_single_run <- function(x, y, delay, umi) {
    .Call('_Scribe_lmi_single_run', PACKAGE = 'Scribe', x, y, delay, umi)
}

lmi_multiple_run_cpp <- function(x, y, d = 1L, run_vec = 0L, uniformalize = FALSE) {
    .Call('_Scribe_lmi_multiple_run_cpp', PACKAGE = 'Scribe', x, y, d, run_vec, uniformalize)
}

#' @title
#' lmi_multiple_run
#' @description
#' This subroutine calculates the lagged mutual information with multiple realization of the same processes. 
#' 
#' @param x one random variable from the time-series data
#' 
#' @param y another random variable from the time-series data
#'
#' @param d Time lags used to estimate the RDI values  
#'
#' @param run_vec A integer vector encodes the information of the run id (run id start from 0) 
#'
#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. 
#' @details
#' \code{lmi_multiple_run} takes two random variables x and y, each has multiple realization of the same process and estimated their mutual information with a time lag d. 
#' using the KSG estimator. 
#' It relies on the ANN package to query the kNN with KDTree algorithm. 
#' @return a numeric value for the estimated mutual information between two variables (x, y) with a time lag d. 
#' @export
lmi_multiple_run <- function(x, y, d, run_vec, umi) {
    .Call('_Scribe_lmi_multiple_run', PACKAGE = 'Scribe', x, y, d, run_vec, umi)
}

#' @title
#' rdi_single_run_conditioned
#' @description
#' This function estimates the CONDITIONED DIRECTED mutual information from X to Y CONDITIONED ON Z when you have a SINGLE run of the processes
#' 
#' @param x one random variable from the time-series data
#' 
#' @param y another random variable from the time-series data
#' 
#' @param z z is a dataframe or matrix consisting of the data for different variables which will be conditioned on. 
#' 
#' @param z_delays z_delay is also a dataframe or matrix consisting of the delays to be applied to different variables
#' 
#' @param d delay in the formula I(x-->y)=I(x_{t-d};y_t|y_{t-1}) default: d=1
#'
#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. 
#' @details
#' \code{rdi_single_run_conditioned} takes two random variables x and y as well as the parameter d to calculate the restricted direct information conditioned on variable z. 
#' @return a numeric value for the estimated condition mutual information between variable x and y conditioning on a third variable z 
#' @export
rdi_single_run_conditioned <- function(x, y, z, z_delays, d, uniformalize) {
    .Call('_Scribe_rdi_single_run_conditioned', PACKAGE = 'Scribe', x, y, z, z_delays, d, uniformalize)
}

extract_max_rdi_value_delay <- function(rdi_result, delays) {
    .Call('_Scribe_extract_max_rdi_value_delay', PACKAGE = 'Scribe', rdi_result, delays)
}

calculate_rdi_cpp <- function(expr_data, delays, super_graph, turning_points, method, uniformalize = FALSE) {
    .Call('_Scribe_calculate_rdi_cpp', PACKAGE = 'Scribe', expr_data, delays, super_graph, turning_points, method, uniformalize)
}

#' @title
#' calculate_rdi_cpp_wrap
#' @description
#' This function estimates the DIRECTED mutual information for all gene pairs in the expr_data matrix when you have a SINGLE run of the processes
#' 
#' @param expr_data a matrix for all variables in a time-series where each row is a time point and each column is a variable (for example, a gene). 
#' The rows are ordered according to time, from earliest to latest. 
#' 
#' @param delays An integer vector storing the time delays between pairs of variables you would like to try. 
#' 
#' @param super_graph An integer matrix where each row is the variable IDs or gene pairs you would like to estimate restricted direct information (RDI) from. 
#'  
#' @param turning_points Either 0 or a numeric vector describing the inflection point (linear trajectory) or branch point (bifurcation point) for each gene. 
#' If the turning_point for each gene is provided, the time delay will be estimated based on the turning point. 
#'
#' @param method An integer of either 1 or 2 to determine which information metric will be used to quantify the causality. 
#' If method is 1, then lagged mutual information will be used; if method is 2, then the restricted direct information will be used. 
#'
#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. 
#' @details
#' \code{calculate_rdi_cpp_wrap} takes an expression matrix (expr_data) and possible gene pairs (encoded in super_graph) to estimate the restricted 
#' direct information based on the time delay which can be estimated from the turning_point vector. 
#' @return a numeric matrix of conditional RDI values for all possible pairs of genes from expr_data. If the gene pairs is not encoded in the super_graph, it will remain as 0 in the matrix.  
#' @export
calculate_rdi_cpp_wrap <- function(expr_data, delays, super_graph, turning_points, method, uniformalize) {
    .Call('_Scribe_calculate_rdi_cpp_wrap', PACKAGE = 'Scribe', expr_data, delays, super_graph, turning_points, method, uniformalize)
}

extract_top_incoming_nodes_delays <- function(max_rdi_value, max_rdi_delays, k = 1L) {
    .Call('_Scribe_extract_top_incoming_nodes_delays', PACKAGE = 'Scribe', max_rdi_value, max_rdi_delays, k)
}

#' @title
#' calculate_conditioned_rdi_cpp_wrap
#' @description
#' This function estimates the conditional DIRECTED mutual information for all gene pairs in the expr_data matrix when you have a SINGLE run of the processes.
#' 
#' @param expr_data a matrix for all variables in a time-series where each row is a time point and each column is a variable (for example, a gene). 
#' The rows are ordered according to time, from earliest to latest. 
#' 
#' @param super_graph An integer matrix where each row is the variable IDs or gene pairs you would like to estimate restricted direct information (RDI) from. 
#'  
#' @param max_rdi_value A numeric matrix where each element corresponding to the maximal (identified from a series of time lags when calculating the rdi values) rdi value between two variables.  
#' 
#' @param max_rdi_delays An integer matrix where each element corresponding to the time delay corresponding to the maximal (identified from a series of time lags when calculating the rdi values) rdi value between two variables.  
#'
#' @param k An integer for the number of incoming nodes to be conditioned on 
#'
#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. 
#' @details
#' \code{calculate_conditioned_rdi_cpp_wrap} takes an expression matrix (expr_data) and possible gene pairs (encoded in super_graph), as well as the matrices of maximal rdi value or the delays corresponding to those values to 
#' estimate the conditional restricted direct information, conditioning on top k incoming nodes. 
#' @return a numeric matrix of conditional RDI values for all possible pairs of genes from expr_data. If the gene pairs is not encoded in the super_graph, it will remain as 0 in the matrix.  
#' @export
calculate_conditioned_rdi_cpp_wrap <- function(expr_data, super_graph, max_rdi_value, max_rdi_delays, k, uniformalize) {
    .Call('_Scribe_calculate_conditioned_rdi_cpp_wrap', PACKAGE = 'Scribe', expr_data, super_graph, max_rdi_value, max_rdi_delays, k, uniformalize)
}

#' @title
#' smooth_gene
#' @description
#' This subroutine takes a time-series data and returns a moving average for the data. 
#' 
#' @param expr_data a matrix for all variables in a time-series where each row is a time point and each column is a variable (for example, a gene). 
#' The rows are ordered according to time, from earliest to latest. 
#' 
#' @param window_size Integer value for the smoothing window used for calculating the moving average.  
#'
#' @details
#' \code{entropy} takes a integer of dimensions and then calculate the olume of a d-dimensional unit ball for Euclidean norm
#' using the formula: 0.5 * d * log(pi) - log(gamma(0.5 * d + 1))
#' It's implimented in C++, providing a (small) increase in speed over the R equivalent.
#' @return a updated matrix with gene expression smoothed with window size equal to window_size
#' @export
smooth_gene <- function(expr_data, window_size = 40L) {
    .Call('_Scribe_smooth_gene', PACKAGE = 'Scribe', expr_data, window_size)
}

rdi_multiple_run_cpp <- function(x, y, d = 1L, run_vec = 0L, uniformalize = FALSE) {
    .Call('_Scribe_rdi_multiple_run_cpp', PACKAGE = 'Scribe', x, y, d, run_vec, uniformalize)
}

calculate_rdi_multiple_run_cpp <- function(expr_data, delays, run_vec, super_graph, turning_points = 0L, method = 1L, uniformalize = FALSE) {
    .Call('_Scribe_calculate_rdi_multiple_run_cpp', PACKAGE = 'Scribe', expr_data, delays, run_vec, super_graph, turning_points, method, uniformalize)
}

#' @title
#' calculate_rdi_multiple_run_cpp_wrap
#' @description
#' This function estimates the DIRECTED mutual information for all gene pairs in the expr_data matrix when you have a SINGLE run of the processes
#' 
#' @param expr_data a matrix for all variables in a time-series where each row is a time point and each column is a variable (for example, a gene). 
#' The rows are ordered according to time, from earliest to latest. 
#' 
#' @param delays An integer vector storing the time delays between pairs of variables you would like to try. 
#' 
#' @param super_graph An integer matrix where each row is the variable IDs or gene pairs you would like to estimate restricted direct information (RDI) from. 
#'  
#' @param turning_points Either 0 or a numeric vector describing the inflection point (linear trajectory) or branch point (bifurcation point) for each gene. 
#' If the turning_point for each gene is provided, the time delay will be estimated based on the turning point. 
#'
#' @param method An integer of either 1 or 2 to determine which information metric will be used to quantify the causality. 
#' If method is 1, then lagged mutual information will be used; if method is 2, then the restricted direct information will be used. 
#'
#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. 
#' @details
#' \code{calculate_rdi_multiple_run_cpp_wrap}, similar to calculate_rdi_cpp_wrap, takes an expression matrix (expr_data) and possible gene pairs (encoded in super_graph) to estimate the restricted 
#' direct information based on the time delay which can be estimated from the turning_point vector. It, however, differs to calculate_rdi_cpp_wrap, in that it can concatenate different experiments (runs) into a single run of the data for causality estimation. 
#' @return a numeric matrix of conditional RDI values for all possible pairs of genes from expr_data. If the gene pairs is not encoded in the super_graph, it will remain as 0 in the matrix.  
#' @export
calculate_rdi_multiple_run_cpp_wrap <- function(expr_data, delays, run_vec, super_graph, turning_points, method, uniformalize) {
    .Call('_Scribe_calculate_rdi_multiple_run_cpp_wrap', PACKAGE = 'Scribe', expr_data, delays, run_vec, super_graph, turning_points, method, uniformalize)
}

rdi_multiple_runs_conditioned_cpp <- function(x, y, z, z_delays, d = 1L, run_vec = 0L, uniformalize = FALSE) {
    .Call('_Scribe_rdi_multiple_runs_conditioned_cpp', PACKAGE = 'Scribe', x, y, z, z_delays, d, run_vec, uniformalize)
}

#' @title
#' This function simulates the CONDITIONED DIRECTED mutual information from X to Y CONDITIONED ON Z when you have a SINGLE run of the processes
#' @description
#' This subroutine calculates the volume of a d-dimensional unit ball for Euclidean norm
#' 
#' @param x one random variable from the time-series data
#' 
#' @param y another random variable from the time-series data
#' 
#' @param z z is a dataframe or matrix consisting of the data for different variables
#' 
#' @param z_delays z_delay is also a dataframe or matrix consisting of the delays to be applied to different variables
#' 
#' @param d delay in the formula I(x-->y)=I(x_{t-d};y_t|y_{t-1}) default: d=1
#'
#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. 
#' @details
#' \code{rdi_single_run_conditioned} takes two random variables x and y as well as the parameter n to calculate the restricted direct information conditioned on variable z. 
#' @return a matrix for the condition mutual information estimators between all pairwise variables (x, y) in the data matrix x, y
#' @export
rdi_multiple_runs_conditioned <- function(x, y, z, z_delays, d, run_vec, uniformalize) {
    .Call('_Scribe_rdi_multiple_runs_conditioned', PACKAGE = 'Scribe', x, y, z, z_delays, d, run_vec, uniformalize)
}

calculate_conditioned_rdi_multiple_run_cpp <- function(expr_data, super_graph, max_rdi_value, max_rdi_delays, run_vec = 0L, k = 1L, uniformalize = FALSE) {
    .Call('_Scribe_calculate_conditioned_rdi_multiple_run_cpp', PACKAGE = 'Scribe', expr_data, super_graph, max_rdi_value, max_rdi_delays, run_vec, k, uniformalize)
}

#' @title
#' calculate_conditioned_rdi_multiple_run_wrap
#' @description
#' This function estimates the conditional DIRECTED mutual information for all gene pairs in the expr_data matrix when you have a SINGLE run of the processes.
#' 
#' @param expr_data a matrix for all variables in a time-series where each row is a time point and each column is a variable (for example, a gene). 
#' The rows are ordered according to time, from earliest to latest. 
#' 
#' @param super_graph An integer matrix where each row is the variable IDs or gene pairs you would like to estimate restricted direct information (RDI) from. 
#'  
#' @param max_rdi_value A numeric matrix where each element corresponding to the maximal (identified from a series of time lags when calculating the rdi values) rdi value between two variables.  
#' 
#' @param max_rdi_delays An integer matrix where each element corresponding to the time delay corresponding to the maximal (identified from a series of time lags when calculating the rdi values) rdi value between two variables.  
#'
#' @param run_vec An integer vector keeping the run id for each sample. 
#'
#' @param k An integer for the number of incoming nodes to be conditioned on.
#'
#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. 
#' @details
#' \code{calculate_conditioned_rdi_multiple_run_wrap}, similar to calculate_conditioned_rdi_cpp_wrap, takes an expression matrix (expr_data) and possible gene pairs (encoded in super_graph), as well as the matrices of maximal rdi value or the delays corresponding to those values to 
#' estimate the conditional restricted direct information, conditioning on top k incoming nodes. It, however, differs to calculate_conditioned_rdi_cpp_wrap, in that it can concatenate different experiments (runs) into a single run of the data for causality estimation. 
#' @return a numeric matrix of conditional RDI values for all possible pairs of genes from expr_data. If the gene pairs is not encoded in the super_graph, it will remain as 0 in the matrix.  
#' @export
calculate_conditioned_rdi_multiple_run_wrap <- function(expr_data, super_graph, max_rdi_value, max_rdi_delays, run_vec, k, uniformalize) {
    .Call('_Scribe_calculate_conditioned_rdi_multiple_run_wrap', PACKAGE = 'Scribe', expr_data, super_graph, max_rdi_value, max_rdi_delays, run_vec, k, uniformalize)
}

calculate_umi_cpp <- function(expr_data, super_graph, k, method, k_density, bw) {
    .Call('_Scribe_calculate_umi_cpp', PACKAGE = 'Scribe', expr_data, super_graph, k, method, k_density, bw)
}

calculate_umi_cpp_wrap <- function(expr_data, super_graph, k, method, k_density, bw) {
    .Call('_Scribe_calculate_umi_cpp_wrap', PACKAGE = 'Scribe', expr_data, super_graph, k, method, k_density, bw)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('_Scribe_RcppExport_registerCCallable', PACKAGE = 'Scribe')
})
